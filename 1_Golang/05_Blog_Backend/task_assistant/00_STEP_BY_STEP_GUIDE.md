# 博客后端项目 - 纯文字版实现指南 - MySQL 版本

## 🎯 项目总体目标与开发理念

你要构建一个完整的博客后端系统。采用**迭代开发**方法：完成一个功能模块后立即测试验证，逐步构建完整系统。这样每一步都能 `go run main.go` 看到实际效果，而不是等到所有代码都写完再测试。

## 📚 项目完成检查清单

- [x] 第1步：依赖安装完成（go.mod 中有所有依赖，使用 MySQL 驱动）
- [x] 第2步：目录结构创建完成（包括 .env 文件）
- [x] 第3步：config/config.go 和 .env 创建完成
- [x] 第4步：最小 main.go ��建并测试成功
- [x] 第5步：models/ 下三个模型文件创建完成
- [x] 第6步：MySQL 数据库创建完成，database/db.go 创建完成并测试连接
- [ ] 第7步：utils/ 下三个工具文件创建完成
- [ ] 第8步：middleware/auth.go 创建完成
- [ ] 第9步：handlers/auth.go 创建完成
- [ ] 第10步：handlers/post.go 创建完成
- [ ] 第11步：handlers/comment.go 创建完成
- [ ] 第12步：routes/routes.go 创建完成
- [ ] 第13步：完整 main.go 创建完成
- [ ] 程序成功运行：`go run main.go`
- [ ] 用 Postman 成功测试所有 9 个接口
- [ ] MySQL 数据库成功存储和检索数据

---

## 📍 第一步：项目初始化和依赖安装

**目的：** 设置 Go 项目并安装所有必要的第三方库。

**操作说明：**

1. 打开终端，进入项目目录 `/home/soulink/workspace/BCCP/1_Golang/05_Blog_Backend`
2. 如果 `go.mod` 不存在，运行命令初始化模块
3. 下载以下库，每个库都有特定的用途：
   - `gin-gonic/gin` - 用于构建 HTTP 服务器和处理路由
   - `gorm` - 用于操作数据库（ORM 库）
   - `gorm/driver/mysql` - **MySQL 数据库驱动**（注意：不是 sqlite）
   - `golang-jwt/jwt/v5` - 用于生成和验证用户身份令牌（JWT）
   - `crypto/bcrypt` - 用于安全地加密和验证密码
   - `godotenv` - 用于读取 .env 文件中的环境变量配置

**完成标志：** 所有依赖都已下载，可以在 `go.mod` 和 `go.sum` 中看到这些库。go.mod 中应该看到 `mysql` 而不是 `sqlite`。

---

## 📁 第二步：创建项目目录结构

**目的：** 组织代码，使项目结构清晰、易于维护。

**操作说明：**

在项目目录下创建以下 8 个文件夹和 1 个配置文件：

1. **config/** - 存放配置文件（如数据库信息、服务器端口、JWT 密钥等）
2. **models/** - 存放数据模型定义（对应数据库表结构）
3. **database/** - 存放数据库连接和初始化代码
4. **handlers/** - 存放处理 HTTP 请求的逻辑代码
5. **middleware/** - 存放中间件（如认证检查）
6. **routes/** - 存放路由配置（定义哪个 URL 对应哪个处理函数）
7. **utils/** - 存放工具函数（如密码加密、JWT 生成等）
8. **logs/** - 存放日志文件（可选）
9. **.env** - 存放环境变量（包含敏感信息如数据库密码）

**完成标志：** 这 8 个文件夹都已创建，.env 文件也已创建

---

## 🔧 第三步：创建配置文件和 .env 文件

**目的：** 集中管理项目的全局配置，特别是数据库连接信息。

**操作说明：**

### 3.1 创建 .env 文件
在项目根目录创建 `.env` 文件。这个文件应该包含：
- `DB_HOST` - MySQL 服务器地址（如 127.0.0.1 表示本地）
- `DB_PORT` - MySQL 服务器端口（默认 3306）
- `DB_USER` - MySQL 用户名（如 root）
- `DB_PASSWORD` - MySQL 密码（你设置的密码）
- `DB_NAME` - 数据库名称（如 blog_backend）
- `API_PORT` - API 服务器监听的端口（如 :8080）
- `JWT_SECRET` - JWT 密钥（用来签名和验证 JWT Token）

**重要提示：** 如果你要提交代码到 GitHub，记得在 `.gitignore` 中添加 `.env` 文件名，防止敏感信息（如密码）泄露。

### 3.2 创建 config/config.go 文件
在 `config/` 文件夹中创建 `config.go` 文件。这个文件应该：

1. 定义一个 `Config` 结构体，包含七个字段：
   - `DBUser` - 数据库用户名
   - `DBPassword` - 数据库密码
   - `DBHost` - 数据库主机地址
   - `DBPort` - 数据库端口号
   - `DBName` - 数据库名称
   - `Port` - API 服务器端口
   - `Secret` - JWT 密钥

2. 定义一个 `GetDSN()` 方法，这个方法应该：
   - 接收一个 Config 对象作为接收者
   - 将 Config 的属性组合成一个 MySQL 连接字符串（DSN）
   - 返回这个连接字符串
   - DSN 格式：`用户:密码@tcp(主机:端口)/数据库?charset=utf8mb4&parseTime=True&loc=Local`

3. 定义一个 `LoadConfig()` 函数，这个函数应该：
   - 调用 `godotenv.Load()` 从 .env 文件读取环境变量
   - 使用 `os.Getenv()` 获取各个环境变量的值
   - 组装成一个 Config 结构体
   - 返回这个 Config 对象

**完成标志：** config.go 文件创建完成，能通过调用 `config.LoadConfig()` 获取配置对象，能通过 `cfg.GetDSN()` 获取 MySQL 连接字符串

---

## 🚀 第四步：创建最小化 main.go（可立即测试）

**目的：** 创建一个最小可运行的项目，只加载配置，其他功能先注释。这样能立即测试项目是否正确设置。

**操作说明：**

编辑 `main.go` 文件。这个文件应该：

1. 定义 `package main`
2. 导入必要的包（config 包、fmt 包）
3. 定义 `main()` 函数，函数应该：
   - 打印启动信息（如"🚀 博客后端启动中..."）
   - 调用 `config.LoadConfig()` 加载配置
   - 打印配置加载成功的消息，显示端口号
   - 其他功能先用 TODO 注释标记，表示稍后会添加（如 TODO: 初始化数据库）
   - 打印初始化完成的消息

**测试方法：** 运行 `go run main.go`，应该看到配置加载成功的消息，没有错误信息

**为什么这样做：** 虽然现在功能很少，但这个"最小可运行"的版本让我们能立即验证项目设置是否正确。等到后续添加更多功能后，这个最小版本会逐步演进。

---

## 💾 第五步：创建数据模型

**目的：** 定义数据结构，这些结构体会自动映射到数据库表。

**操作说明：**

在 `models/` 文件夹中创建三个文件，分别定义三个核心数据模型：

### 5.1 User 模型（用户）文件：models/user.go
这个结构体需要包含以下字段：
- `ID` - 用户的唯一标识符（自动生成，主键）
- `Username` - 用户名（必填，不能重复，varchar(255)）
- `Email` - 邮箱（必填，不能重复，varchar(255)）
- `Password` - 密码哈希值（必填，varchar(255)，JSON 序列化时不返回给客户端）
- `PostCount` - 用户发布的文章数量
- `Posts` - 用户发布的所有文章的引用（一对多关系）
- `Comments` - 用户发表的所有评论的引用（一对多关系）

### 5.2 Post 模型（文章）文件：models/post.go
这个结构体需要包含以下字段：
- `ID` - 文章的唯一标识符（主键）
- `Title` - 文章标题（必填）
- `Content` - 文章内容
- `UserID` - 作者的 ID（外键，关联到 User）
- `User` - 作者对象的引用
- `Comments` - 文章的所有评论（一对多关系）
- `CreatedAt` - 创建时间（GORM 自动记录）
- `UpdatedAt` - 最后修改时间（GORM 自动更新）

### 5.3 Comment 模型（评论）文件：models/comment.go
这个结构体需要包含以下字段：
- `ID` - 评论的唯一标识符（主键）
- `Content` - 评论内容（必填）
- `CommenterID` - 评论者的 ID（外键，关联到 User）
- `Commenter` - 评论者对象的引用
- `PostId` - 所属文章的 ID（外键，关联到 Post）
- `Post` - 文章对象的引用
- `CreatedAt` - 创建时间（自动记录）

**完成标志：** 三个模型文件都定义好了，能清晰看到数据之间的关系

---

## 🗄️ 第六步：创建 MySQL 数据库和数据库初始化

**目的：** 连接到 MySQL 数据库并自动创建表结构。

**操作说明：**

### 6.1 在 MySQL 中创建数据库
在 MySQL 命令行中执行以下命令：

```sql
CREATE DATABASE blog_backend CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
```

这个命令做了三件事：
- 创建名为 `blog_backend` 的数据库
- 指定字符集为 `utf8mb4`（支持中文和 emoji）
- 指定排序规则为 `utf8mb4_unicode_ci`（Unicode 并且不区分大小写）

### 6.2 创建 database/db.go 文件
在 `database/` 文件夹中创建 `db.go` 文件。这个文件应该定义一个 `InitDB()` 函数，这个函数应该：

1. 接收配置对象作为参数
2. 调用配置对象的 `GetDSN()` 方法获取 MySQL 连接字符串
3. 使用 GORM 的 `mysql.Open()` 打开 MySQL 数据库
4. 进行"自动迁移"操作（根据你定义的模型自动创建对应的数据库表）
5. 如果出错，应该记录错误日志
6. 返回数据库连接对象，供后续代码使用

### 6.3 更新 main.go 来测试数据库连接
此时 `main.go` 应该：
1. 导入 database 包
2. 加载配置（第三步）
3. 调用 `database.InitDB()` 初始化数据库
4. 验证数据库连接是否成功（通过调用 db.Ping()）
5. 打印成功消息
6. 其他功能仍然保持 TODO 注释

**测试方法：** 运行 `go run main.go`，应该看到数据库初始化成功的消息，并且数据库连接验证成功

**此时的效果：** 项目现在可以连接和初始化 MySQL 数据库，表结构自动创建

---

## 🔐 第七步：创建工具函数

**目的：** 提供可重用的工具函数，处理密码加密、JWT 生成等常见任务。

**操作说明：**

在 `utils/` 文件夹中创建三个文件：

### 7.1 创建 utils/password.go（密码工具）

这个文件应该提供两个函数：

**HashPassword 函数：**
- 接收一个明文密码字符串
- 使用 bcrypt 算法加密密码（这是一种单向加密，无法逆向解密）
- 返回加密后的密码哈希值和错误信息
- 用途：当用户注册或修改密码时调用

**CheckPassword 函数：**
- 接收两个参数：已加密的密码哈希值和用户输入的明文密码
- 比对两者是否匹配
- 返回布尔值（true 表示匹配，false 表示不匹配）
- 用途：当用户登录时验证密码

### 7.2 创建 utils/jwt.go（JWT 工具）

这个文件应该定义 `Claims` 结构体和两个函数：

**Claims 结构体：**
- 包含 `UserID` 字段（用来存储用户 ID）
- 包含 JWT 标准声明字段（如过期时间、签发时间等）

**GenerateToken 函数：**
- 接收用户 ID 作为参数
- 创建一个包含用户 ID 和过期时间（24 小时后）的 Claims 对象
- 使用 HS256 算法生成一个 JWT Token
- 返回 Token 字符串
- 用途：用户登录成功后生成 Token 返回给客户端

**ValidateToken 函数：**
- 接收一个 Token 字符串
- 验证 Token 的签名是否有效
- 验证 Token 是否过期
- 返回 Token 中包含的信息（如用户 ID）或错误信息
- 用途：处理需要认证的请求时验证客户端提供的 Token

### 7.3 创建 utils/response.go（响应工具）

这个文件应该定义 `Response` 结构体和两个函数，用于返回统一格式的 JSON 响应：

**Response 结构体：**
- 包含 `Code` 字段（HTTP 状态码或自定义业务码）
- 包含 `Message` 字段（响应消息）
- 包含 `Data` 字段（具体的响应数据，可以是任何类型）

**Success 函数：**
- 用于返回成功响应
- 接收 Gin 上下文、响应码、消息、数据
- 组装成统一格式的 JSON 并返回给客户端

**Error 函数：**
- 用于返回错误响应
- 接收 Gin 上下文、错误码、错误消息
- 组装成统一格式的 JSON 并返回给客户端

**好处：** 所有 API 响应都是统一的格式，客户端更容易处理

---

## 🔐 第八步：创建认证中间件

**目的：** 保护需要身份验证的接口，防止未授权访问。

**操作说明：**

在 `middleware/` 文件夹中创建 `auth.go` 文件。这个文件应该定义一个 `AuthMiddleware()` 函数，返回一个中间件处理程序。

这个中间件应该：
1. 检查 HTTP 请求的 `Authorization` 请求头
2. 如果没有 `Authorization` 头，返回 401 未授权错误
3. 从 `Authorization` 头中提取 JWT Token（通常格式是 "Bearer token"）
4. 使用第七步中定义的 `ValidateToken` 函数验证 Token
5. 如果 Token 无效或过期，返回 401 未授权错误
6. 如果 Token 有效，将用户 ID 存储在请求上下文中
7. 允许请求继续流转到下一个处理程序

**工作流程：**
```
请求到达 → 检查 Token → Token 有效? → 是: 放行请求，否: 返回 401 错误
```

**注意：** 这个中间件的核心是验证，不处理业务逻辑。只有拥有有效 Token 的请求才能继续进行。

---

## 👤 第九步：创建用户认证处理程序

**目的：** 处理用户注册和登录请求。

**操作说明：**

在 `handlers/` 文件夹中创建 `auth.go` 文件。这个文件应该定义两个主要函数：

### 9.1 Register 函数（用户注册）
这个函数应该：
1. 接收 HTTP POST 请求，请求体应包含：用户名、邮箱、密码
2. 验证这些字段是否都提供了（不能为空）
3. 查询数据库，检查用户名是否已被占用
4. 如果用户名已存在，返回 409 冲突错误
5. 使用第七步的 `HashPassword` 函数加密密码
6. 创建新用户记录并保存到数据库
7. 返回成功响应，包含新用户的 ID 和用户名（不返回密码）

### 9.2 Login 函数（用户登录）
这个函数应该：
1. 接收 HTTP POST 请求，请求体应包含：用户名、密码
2. 验证这些字段是否都提供了
3. 查询数据库，找到对应用户名的用户记录
4. 如果用户不存在，返回 401 未授权错误（"用户名或密码错误"）
5. 使用第七步的 `CheckPassword` 函数验证密码
6. 如果密码错误，返回 401 未授权错误
7. 如果用户名和密码都正确，使用第七步的 `GenerateToken` 函数生成 JWT Token
8. 返回成功响应，包含 Token 和用户信息

**测试点：** 此时可以测试用户注册和登录功能，获得 JWT Token

---

## 📝 第十步：创建文章处理程序

**目的：** 处理文章的增删改查（CRUD）操作。

**操作说明：**

在 `handlers/` 文件夹中创建 `post.go` 文件。这个文件应该定义五个函数：

### 10.1 CreatePost 函数（创建文章）
这个函数应该：
1. 检查请求是否经过认证（使用第八步的中间件提供的用户 ID）
2. 从请求体中获取文章标题和内容
3. 验证标题和内容都不为空
4. 从请求上下文中获取当前用户 ID
5. 创建文章记录并保存到数据库
6. 返回成功响应，包含创建的文章信息

### 10.2 GetAllPosts 函数（获取所有文章）
这个函数应该：
1. 不需要认证，任何人都可以访问
2. 从数据库查询所有文章
3. 对于每篇文章，关联加载对应的作者信息（这样前端可以看到作者名字）
4. 返回成功响应，包含文章列表

### 10.3 GetPost 函数（获取单篇文章）
这个函数应该：
1. 从 URL 参数中获取文章 ID
2. 从数据库查询该文章
3. 如果文章不存在，返回 404 未找到错误
4. 加载文章的作者和评论信息
5. 返回成功响应，包含文章的详细信息

### 10.4 UpdatePost 函数（更新文章）
这个函数应该：
1. 检查请求是否经过认证
2. 从 URL 参数中获取文章 ID
3. 从数据库查询该文章
4. 检查当前用户是否是文章作者（文章的 UserID 是否与当前用户 ID 相同）
5. 如果不是作者，返回 403 禁止访问错误
6. 从请求体中获取要更新的标题和内容
7. 更新数据库中的文章记录
8. 返回成功响应

### 10.5 DeletePost 函数（删除文章）
这个函数应该：
1. 检查请求是否经过认证
2. 从 URL 参数中获取文章 ID
3. 从数据库查询该文章
4. 检查当前用户是否是文章作者
5. 如果不是作者，返回 403 禁止访问错误
6. 从数据库删除该文章记录
7. 返回成功响应

**权限原则：** 只有文章的作者才能修改或删除自己的文章

---

## 💬 第十一步：创建评论处理程序

**目的：** 处理评论的创建和查询操作。

**操作说明：**

在 `handlers/` 文件夹中创建 `comment.go` 文件。这个文件应该定义两个函数：

### 11.1 CreateComment 函数（创建评论）
这个函数应该：
1. 检查请求是否经过认证
2. 从 URL 参数中获取文章 ID
3. 查询数据库确认该文章存在
4. 如果文章不存在，返回 404 错误
5. 从请求体中获取评论内容
6. 验证评论内容不为空
7. 从请求上下文中获取当前用户 ID
8. 创建评论记录并保存到数据库（包含用户 ID、文章 ID、评论内容）
9. 返回成功响应

### 11.2 GetPostComments 函数（获取文章的所有评论）
这个函数应该：
1. 不需要认证
2. 从 URL 参数中获取文章 ID
3. 从数据库查询该文章的所有评论
4. 对于每条评论，加载对应的评论者信息
5. 返回成功响应，包含评论列表

---

## 🛣️ 第十二步：创建路由配置

**目的：** 定义 URL 端点和处理程序的映射关系，这样 HTTP 请求才知道该调用哪个处理程序。

**操作说明：**

在 `routes/` 文件夹中创建 `routes.go` 文件。这个文件应该定义一个 `SetupRoutes()` 函数，这个函数应该：

1. 接收路由引擎和数据库连接作为参数
2. 创建前面步骤中定义的各个处理程序实例（AuthHandler、PostHandler、CommentHandler）
3. 定义三组路由：

### 12.1 认证路由组（/api/auth）
- `POST /api/auth/register` → 调用 Register 函数（注册新用户）
- `POST /api/auth/login` → 调用 Login 函数（用户登录）
- 这两个路由不需要认证中间件

### 12.2 文章路由组（/api/posts）
- `GET /api/posts` → 调用 GetAllPosts 函数（获取所有文章，不需要认证）
- `GET /api/posts/:id` → 调用 GetPost 函数（获取单篇文章，不需要认证）
- `POST /api/posts` → 调用 CreatePost 函数（创建文章，需要认证中间件）
- `PUT /api/posts/:id` → 调用 UpdatePost 函数（更新文章，需要认证中间件）
- `DELETE /api/posts/:id` → 调用 DeletePost 函数（删除文章，需要认证中间件）

### 12.3 评论路由组（/api/posts/:post_id/comments）
- `GET /api/posts/:post_id/comments` → 调用 GetPostComments 函数（获取评论，不需要认证）
- `POST /api/posts/:post_id/comments` → 调用 CreateComment 函数（创建评论，需要认证中间件）

**关键概念：**
- `:id` 和 `:post_id` 是 URL 参数占位符，真实值会在运行时替换
- 需要认证的路由应该添加认证中间件（这样只有拥有有效 Token 的请求才能访问）

---

## 🎯 第十三步：完成 main.go（启动完整服务）

**目的：** 把所有组件连接起来，启动完整的 HTTP 服务器。

**操作说明：**

编辑 `main.go` 文件为完整版本。这个文件应该：

1. 定义 `main()` 函数，这是程序的入口点
2. 打印启动信息
3. 调用第三步的 `LoadConfig()` 函数加载配置
4. 调用第六步的 `InitDB()` 函数初始化数据库连接
5. 创建一个 Gin 路由引擎
6. 调用第十二步的 `SetupRoutes()` 函数配置所有路由
7. 调用 `router.Run(cfg.Port)` 启动 HTTP 服务器
8. 打印各步骤的成功消息

**程序启动流程：**
```
读取配置 → 连接数据库 → 创建路由引擎 → 配置所有路由 → 启动服务器 → 等待请求
```

**测试：** 运行 `go run main.go`，应该看到服务器成功启动的消息，服务器会在 8080 端口监听请求。

---

## ✅ 完成后的测试步骤

**目的：** 验证整个系统是否正常工作。

**操作说明：**

1. 运行程序：`go run main.go`
2. 打开网页版 Postman（https://web.postman.co/）
3. 按照以下顺序逐个测试接口：

### 测试流程：

**第一步：用户注册**
- 发送 POST 请求到 `/api/auth/register`
- 提供用户名、邮箱、密码
- 应该收到成功响应，包含新用户 ID

**第二步：用户登录**
- 发送 POST 请求到 `/api/auth/login`
- 使用刚注册的用户名和密码
- 应该收到成功响应，包含 JWT Token（这是一个很长的字符串）
- 复制这个 Token，后续需要用到

**第三步：创建文章**
- 发送 POST 请求到 `/api/posts`
- 在请求头中添加 `Authorization: Bearer [你的Token]`
- 提供文章标题和内容
- 应该看到创建的文章信息

**第四步：获取所有文章**
- 发送 GET 请求到 `/api/posts`
- 不需要提供 Token
- 应该看到所有文章的列表

**第五步：获取单篇文章**
- 发送 GET 请求到 `/api/posts/1`（1 是文章 ID）
- 应该看到该文章的详细信息，包括作者和评论

**第六步：更新文章**
- 发送 PUT 请求到 `/api/posts/1`
- 在请求头中添加 Token
- 提供新的标题或内容
- 应该看到更新成功的响应

**第七步：创建评论**
- 发送 POST 请求到 `/api/posts/1/comments`
- 在请求头中添加 Token
- 提供评论内容
- 应该看到创建的评论信息

**第八步：获取评论**
- 发送 GET 请求到 `/api/posts/1/comments`
- 应该看到该文章的所有评论

**第九步：删除文章**
- 发送 DELETE 请求到 `/api/posts/1`
- 在请求头中添加 Token
- 应该看到删除成功的响应

---

## 🎯 项目完成检查清单

按照以下顺序检查每个步骤是否完成：

- [ ] 第1步：依赖安装完成（go.mod 中有所有依赖，使用 MySQL 驱动）
- [ ] 第2步：目录结构创建完成（8 个文件夹 + .env 文件）
- [ ] 第3步：.env 文件创建完成，config/config.go 文件创建完成
- [ ] 第4步：最小 main.go 创建并成功运行（`go run main.go`）
- [ ] 第5步：models/ 下三个模型文件创建完成
- [ ] 第6步：MySQL 数据库创建完成，database/db.go 创建完成，main.go 更新为数据库版本并成功运行
- [ ] 第7步：utils/ 下三个工具文件创建完成
- [ ] 第8步：middleware/auth.go 文件创建完成
- [ ] 第9步：handlers/auth.go 文件创建完成
- [ ] 第10步：handlers/post.go 文件创建完成
- [ ] 第11步：handlers/comment.go 文件创建完成
- [ ] 第12步：routes/routes.go 文件创建完成
- [ ] 第13步：完整 main.go 创建完成并成功运行
- [ ] 程序能成功启动：`go run main.go` 看到服务器启动消息
- [ ] 用 Postman 成功测试所有 9 个接口
- [ ] MySQL 数据库成功存储和检索数据

---

## 📚 项目完成后的效果

完成整个项目后，你将拥有：

✅ **一个完整的 HTTP API 服务器**
- 监听在 8080 端口
- 能接收和处理各种 HTTP 请求
- 返回统一格式的 JSON 响应

✅ **用户系统**
- 用户可以注册新账号（用户名、邮箱、密码加密存储）
- 用户可以登录，获取 JWT Token
- Token 用来验证用户身份和访问受保护的资源

✅ **文章系统**
- 认证用户可以发布新文章
- 任何人都可以查看所有文章
- 用户可以查看单篇文章的详细信息
- 用户只能修改和删除自己的文章

✅ **评论系统**
- 认证用户可以对文章发表评论
- 任何人都可以查看文章的所有评论

✅ **完整的技术栈**
- MySQL 数据库存储和管理数据
- 自动维护创建时间和更新时间
- 自动维护表之间的关系

✅ **安全性**
- 密码使用 bcrypt 加密
- 用户身份使用 JWT Token 验证
- 权限控制确保用户只能修改自己的内容
- 统一的 JSON 错误响应格式

---

## 💡 迭代开发的好处

通过这种逐步构建、逐步测试的方法，你会：

1. **快速看到成果** - 不用等到全部写完才能测试，每一步都能 `go run` 验证
2. **早期发现问题** - 如果某一步有问题，立即就能发现和修复
3. **增强学习效果** - 通过实际运行和测试来理解每个组件的作用
4. **降低错误率** - 完成小任务比完成大任务更容易出错少
5. **符合真实开发** - 专业的软件开发就是这样迭代进行的

这样的方法让你不仅学会了写代码，还学会了实际的开发流程！
